

This is a Spring Data Rest sample project copied from https://github.com/spring-guides/gs-accessing-data-rest/tree/main/complete and beefed up with many examples so it may be used as a template for doing a quick POC microservice project with minimal code. See https://spring.io/guides/gs/accessing-data-rest/ for original tutorial of its code.

Hopefully it can save other people some time in trying to implement similar things. Some of the interesting code samples are highlighted below.


* See SchedulerService.polling() for how to run a scheduled method repeatedly at fixed interval by simply using Spring @Scheduled annotation. For this to work @EnableScheduling also needs to be put in the class that started Spring Boot application. Yes, just 2 lines to make it happen.

  - This polling can also be disabled/enabled at runtime by accessing AdminController's Rest service with URL like
    - http://localhost:8080/admin/polling?disablePolling=t -> disable polling
    - http://localhost:8080/admin/polling?disablePolling=f -> enable polling

    This is implemented by annotating the method SchedulerService.polling() with @SkipExecution(...) plus the use of the method poll(..) in AdminController.

* LogExecutionTime class shows how to implement a simple Spring AOP annotation to log performance of any method. To use it, simply add @LogExecutionTime above the method to log its execution time.

* ApiRateLimiter - Used to control rate limit of an API, e.g. 60 per minute. See ApiRateLimiterTest for its behaviors.

* FreeMarkerUtil - Used to parse template file with its placeholder variables swapped to actual values. Useful for generating dynamic content per customer basis. See FreeMarkerUtilTest for usage.

* By default, the lightweight H2 database is used without the need to pre-install any database but this can be changed easily to other database, e.g. MySQL. See https://www.baeldung.com/spring-boot-h2-database for how H2 is configured.

  Note the actual database tables are generated by JPA (e.g. Person) when the application starts up. Great for prototyping an app without database designed upfront but make it up as required using JPA.

  Default H2 database can be accessed at http://localhost:8080/h2-console/ in browser after startup of Spring Boot application. No password required.

Note any SQL INSERT put in /src/main/resources/import.sql will be used to pre-populate the database when starting up the application. Likewise, any SQL INSERT put in /src/test/resources/import.sql will be used to pre-populate the database for unit test, e.g. See PersonRepositoryTest. After unit test, any change to the database will be rolled back. This is great for Test Driven Development(TDD) where test data can be created before each unit test. All database transactions should be rolled back by Spring automatically after each unit test => no pollution to the actual database even if it's not H2.

* DemoMultiThreadingServiceEngine - Showcase the POC of a multi-threading application engine simulating the processing of multiple tasks simultaneously. Processing of each task will sleep a few random sec to simulate work.
  
  - Java multi-threading can be very confusing, this https://www.topcoder.com/thrive/articles/Thread%20Pool%20in%20Java should clear up things a little bit

  - See BlockingExecutor for how Semaphore is used to block tasks from submission to throttle task submission

  - Thread pool size(i.e. maximum thread/worker) and queue size are configured in application.properties.

    Ideal thread pool size? This is not easy to pinpoint and requires estimate using Little's law. See https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html.

  - AdminController: a Rest service to control, test and monitor performance of DemoMultiThreadingServiceEngine at runtime

    - http://localhost:8080/admin/mock?testData=100 -> mock 100 tasks for processing
    - http://localhost:8080/admin/monitor?enable=t -> enable monitoring to produce extra logging as below every 3 sec

            ...
            Active threads running tasks: 3
            Tasks completed: 7
            Tasks waiting in queue: 5
            Unprocessed tasks outside queue: 14
            ...

	  http://localhost:8080/admin/monitor?enable=f -> disable monitoring

    - http://localhost:8080/admin/stop -> Stop the engine
    - http://localhost:8080/admin/start -> Restart the engine

  - See TimeoutProcessor for how to terminate processing of a task that's taking too long


* JavaStream1Test - Java 8 stream exercise to filter, manipulate, sort and transform an array to List/Map in just one or two lines of code. Learn to do this if one doesn't want to flunk Java coding interviews.

* PersonRepository is used in https://spring.io/guides/gs/accessing-data-rest/ to showcase how a Rest service can be created with minimal code. While good for demo, it's bad for Prod code, much better practice is to create a service layer class (i.e. PersonService) to delegate call to PersonRepository. Then a Rest controller class (i.e. PersonController) to expose actual service by using PersonService. Why? For security and fine-grained access control. Also service layer will be the perfect place to implement more complicated use cases and group multiple database transactions into one then roll it back if anything goes wrong, e.g. unexpected Exception happens.

* Basic authentication is now implemented for Rest API. Using it is as simple as adding the annotation @BasicAuthentication as input argument in the controller's mapping method. See BasicAuthenticationTestController for how to use it.

  Why use the annotation approach as opposed to using classic Spring Security XML config or Java config class (that extends WebSecurityConfigurerAdapter) to specify all the URLs that requires basic authentication?

  Well... because
    1. Spring Security is a bit heavy weight, not all Spring Boot projects need it

    2. I don't like the idea of centralizing security of all URLs to a single XML/Java file unless I have to. Introducing a bug means potentially breaking every other service at once! Not to mention testing. To guarantee 100% nothing else is broken requires testing most if not all the Rest API specified in that file again.

       Having said that, using Spring Security approach may be the way to go for big projects or projects requiring complex security features supported out of box by Spring Security.

    3. By just looking at a controller's mapping method, I know Basic Authentication is required, no need to double-check XML/Java config file

    4. It's way cooler to use annotation...

   The infrastructure code to make it happens are BasicAuthentication, AuthenticationException, BasicAuthenticationException, BasicAuthenticationHandler, BasicAuthenticationResolver. To fully understand how it all works together, google it!

   To adapt this for production, modify BasicAuthenticationHandler to query database for user credential. It's using hard-coded credential right now for authentication. See BasicAuthenticationApiTest for its unit tests.


